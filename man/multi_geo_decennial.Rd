% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multi_geo_fetch.R
\name{multi_geo_decennial}
\alias{multi_geo_decennial}
\title{Fetch a decennial census table with multiple geography levels}
\usage{
multi_geo_decennial(
  table,
  year = 2020,
  towns = "all",
  regions = NULL,
  counties = "all",
  state = "09",
  neighborhoods = NULL,
  tracts = NULL,
  blockgroups = NULL,
  msa = FALSE,
  us = FALSE,
  new_england = TRUE,
  nhood_name = name,
  nhood_geoid = geoid,
  nhood_weight = weight,
  sumfile = c("dhc", "sf1", "sf3", "pl"),
  verbose = TRUE,
  key = NULL,
  sleep = 0,
  ...
)
}
\arguments{
\item{table}{A string giving the decennial census table number. These are generally formatted as one or more letters, 3 numbers, and optionally a letter.}

\item{year}{The year of the census table; currently defaults 2020.}

\item{towns}{A character vector of towns to include; \code{"all"} (default) for all towns optionally filtered by county; or \code{NULL} to not fetch town-level table.}

\item{regions}{A named list of regions with their town names (defaults \code{NULL}).}

\item{counties}{A character vector of counties to include; \code{"all"} (default) for all counties in the state; or \code{NULL} to not fetch county-level table.}

\item{state}{A string: either name or two-digit FIPS code of a US state. Required; defaults \code{"09"} (Connecticut).}

\item{neighborhoods}{A data frame with columns for neighborhood name, GEOID of tracts, and weight, e.g. share of each tract assigned to a neighborhood. If included, weighted sums will be returned for neighborhoods. Unlike \code{multi_geo_acs}, this doesn't take block groups.}

\item{tracts}{A character vector of 11-digit FIPS codes of tracts to include, or \code{"all"} for all tracts optionally filtered by county. Defaults \code{NULL}.}

\item{blockgroups}{A character vector of 12-digit FIPS codes of block groups to include, or \code{"all"} for all block groups optionally filtered by county. Defaults \code{NULL}.}

\item{msa}{Logical: whether to fetch New England states' metropolitan statistical areas. Defaults \code{FALSE}.}

\item{us}{Logical: whether to fetch US-level table. Defaults \code{FALSE}.}

\item{new_england}{Logical: if \code{TRUE} (the default), limits metro areas to just New England states.}

\item{nhood_name}{Bare column name of neighborhood names. Only relevant if a neighborhood weight table is being used. Defaults \code{name} to match the neighborhood lookup datasets.}

\item{nhood_geoid}{Bare column name of neighborhood tract GEOIDs. Only relevant if a neighborhood weight table is being used. Defaults \code{geoid} to match the neighborhood lookup datasets.}

\item{nhood_weight}{Bare column name of weights between neighborhood names and tract/block groups. Only relevant if a neighborhood weight table is being used. Defaults \code{weight} to match the neighborhood lookup datasets.}

\item{sumfile}{A string giving the summary file to pull from. Note that codes have changed between 2010 and 2020. Now that default year is 2020, default sumfile is \code{"dhc"}. For 2010, should be either \code{"sf1"}, or less commonly \code{"sf3"}. Use \code{"pl"} for 2020 redistricting data.}

\item{verbose}{Logical: whether to print summary of geographies included. Defaults \code{TRUE}.}

\item{key}{String: Census API key. If \code{NULL} (default), takes the value from \code{Sys.getenv("CENSUS_API_KEY")}.}

\item{sleep}{Number of seconds, if any, to sleep before each API call. This might help with the Census API's tendency to crash, but for many geographies, it could add a sizable about of time. Probably don't add more than a few seconds.}

\item{...}{Additional arguments to pass on to \code{tidycensus::get_acs}}
}
\value{
A tibble with GEOID, name, variable code, estimate, moe, geography level, state, and year, as applicable, for the chosen table.
}
\description{
Fetch a data table from the decennial census via \code{tidycensus} with your choice of geographies at multiple levels. For geographies made of aggregates, i.e. neighborhoods made of tracts or regions made of towns, the returned table will have estimates summed for the whole area. Any geographic levels that are null will be excluded.
}
\details{
This function essentially calls \code{tidycensus::get_decennial()} multiple times, depending on geographic levels chosen, and does minor cleaning, filtering, and aggregation. Note that the underlying \code{tidycensus::get_decennial()} requires a Census API key. As is the case with other \code{tidycensus} functions, \code{multi_geo_decennial} assumes this key is stored as \code{CENSUS_API_KEY} in your \code{.Renviron}. See \code{\link[tidycensus:census_api_key]{tidycensus::census_api_key()}} for installation.

Be advised that decennial table numbers may change from year to year, so if you're looking at trends, check FactFinder or another source to make sure the tables have the same meaning. Setting \code{verbose = TRUE} is helpful for this as well.
}
\examples{
\dontrun{
multi_geo_decennial("P1", 2020, sumfile = "dhc",
  towns = "all",
  regions = list(inner_ring = c("Hamden", "East Haven", "West Haven")),
  counties = "New Haven County")
}
}
\seealso{
\code{\link[tidycensus:census_api_key]{tidycensus::census_api_key()}}, \code{\link[tidycensus:get_decennial]{tidycensus::get_decennial()}}
}
